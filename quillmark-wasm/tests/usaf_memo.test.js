/**
 * Smoke test to verify WASM PDF output matches native cargo output
 * 
 * This test loads the usaf_memo Quill, renders it using WASM,
 * and compares the PDF output with the reference PDF generated by
 * `cargo run --example usaf_memo`.
 */

import { describe, it, expect, beforeAll } from 'vitest'
import { Quillmark } from '../../pkg/bundler/wasm.js'
import { loadQuill, loadQuillMarkdown } from './quillLoader.js'
import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'
import { execSync } from 'child_process'
import crypto from 'crypto'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Paths relative to the workspace root
const WORKSPACE_ROOT = path.join(__dirname, '..', '..')
const QUILLS_PATH = path.join(WORKSPACE_ROOT, 'quillmark-fixtures', 'resources', 'tonguetoquill-collection', 'quills')
const USAF_MEMO_QUILL_PATH = path.join(QUILLS_PATH, 'usaf_memo')
const CARGO_OUTPUT_PATH = path.join(WORKSPACE_ROOT, 'quillmark-fixtures', 'output', 'usaf_memo_output.pdf')
const WASM_OUTPUT_PATH = path.join(__dirname, 'output', 'usaf_memo_wasm_output.pdf')

describe.skipIf(process.env.CI)('WASM usaf_memo smoke test', () => {
  let quillJson
  let markdown
  let cargoOutputPdf

  beforeAll(() => {
    // Ensure output directory exists
    const outputDir = path.dirname(WASM_OUTPUT_PATH)
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
    }

    // Generate reference PDF using cargo
    console.log('Generating reference PDF with cargo...')
    try {
      execSync('cargo run --example usaf_memo', {
        cwd: WORKSPACE_ROOT,
        stdio: 'inherit'
      })
    } catch (error) {
      throw new Error(`Failed to run cargo example: ${error.message}`)
    }

    // Load the cargo-generated PDF
    if (!fs.existsSync(CARGO_OUTPUT_PATH)) {
      throw new Error(`Cargo output PDF not found at ${CARGO_OUTPUT_PATH}`)
    }
    cargoOutputPdf = fs.readFileSync(CARGO_OUTPUT_PATH)
    console.log(`Cargo PDF loaded: ${cargoOutputPdf.length} bytes`)

    // Load the Quill structure
    console.log('Loading usaf_memo Quill...')
    quillJson = loadQuill(USAF_MEMO_QUILL_PATH)
    
    // Load the markdown example
    const quillmark = new Quillmark()
    let quillInfo = quillmark.registerQuill(quillJson)
    markdown = quillInfo.example
    console.log(`Markdown loaded: ${markdown.length} chars`)
  })

  it('should load usaf_memo Quill successfully', () => {
    expect(quillJson).toBeDefined()
    expect(quillJson.files).toBeDefined()
    expect(quillJson.files['Quill.toml']).toBeDefined()
    expect(quillJson.files['glue.typ']).toBeDefined()
    expect(quillJson.files['usaf_memo.md']).toBeDefined()
  })

  it('should parse usaf_memo markdown', () => {
    const parsed = Quillmark.parseMarkdown(markdown)
    
    expect(parsed).toBeDefined()
    expect(parsed.fields).toBeDefined()
    expect(parsed.quillTag).toBe('usaf_memo')
    expect(parsed.fields.subject).toBeDefined()
    expect(parsed.fields.memo_for).toBeDefined()
    expect(parsed.fields.memo_from).toBeDefined()
  })

  it('should register usaf_memo Quill', () => {
    const engine = new Quillmark()
    
    expect(() => {
      engine.registerQuill(quillJson)
    }).not.toThrow()
    
    const quills = engine.listQuills()
    expect(quills).toContain('usaf_memo')
  })

  it('should get usaf_memo Quill info', () => {
    const engine = new Quillmark()
    engine.registerQuill(quillJson)
    
    const info = engine.getQuillInfo('usaf_memo')
    
    expect(info).toBeDefined()
    expect(info.name).toBe('usaf_memo')
    expect(info.backend).toBe('typst')
    expect(info.supportedFormats).toContain('pdf')
  })

  it('should render usaf_memo to PDF via WASM', () => {
    const parsed = Quillmark.parseMarkdown(markdown)
    const engine = new Quillmark()
    engine.registerQuill(quillJson)
    
    const result = engine.render(parsed, { format: 'pdf' })
    
    expect(result).toBeDefined()
    expect(result.artifacts).toBeDefined()
    expect(result.artifacts.length).toBe(1)
    expect(result.artifacts[0].format).toBe('pdf')
    expect(result.artifacts[0].bytes).toBeDefined()
    expect(result.artifacts[0].bytes.length).toBeGreaterThan(0)
    expect(result.artifacts[0].mimeType).toBe('application/pdf')

    // Save WASM output for comparison
    const wasmPdf = Buffer.from(result.artifacts[0].bytes)
    fs.writeFileSync(WASM_OUTPUT_PATH, wasmPdf)
    console.log(`WASM PDF saved: ${wasmPdf.length} bytes`)
  })

  it('should produce functionally identical PDF output to cargo example', () => {
    // Render via WASM
    const parsed = Quillmark.parseMarkdown(markdown)
    const engine = new Quillmark()
    engine.registerQuill(quillJson)
    
    const result = engine.render(parsed, { format: 'pdf' })
    const wasmPdf = Buffer.from(result.artifacts[0].bytes)

    // Compare file sizes
    console.log(`Cargo PDF: ${cargoOutputPdf.length} bytes`)
    console.log(`WASM PDF: ${wasmPdf.length} bytes`)

    // Compute hashes for comparison
    const cargoHash = crypto.createHash('sha256').update(cargoOutputPdf).digest('hex')
    const wasmHash = crypto.createHash('sha256').update(wasmPdf).digest('hex')

    console.log(`Cargo PDF SHA256: ${cargoHash}`)
    console.log(`WASM PDF SHA256: ${wasmHash}`)

    // PDFs are functionally identical but not byte-identical due to:
    // 1. Random font subset prefixes (e.g., QGBEVL vs DYJZLR)
    // 2. Random document IDs and instance IDs in XMP metadata
    // These are generated fresh on each Typst compilation.
    
    // Verify both PDFs are valid and similar size
    expect(wasmPdf.length).toBeGreaterThan(1000000) // At least 1MB
    expect(cargoOutputPdf.length).toBeGreaterThan(1000000)
    
    // Size should be within 1% of each other (allows for minor variations in compression/encoding)
    const sizeDiff = Math.abs(wasmPdf.length - cargoOutputPdf.length)
    const sizeRatio = sizeDiff / cargoOutputPdf.length
    console.log(`Size difference: ${sizeDiff} bytes (${(sizeRatio * 100).toFixed(2)}%)`)
    expect(sizeRatio).toBeLessThan(0.05) // Within 5%
    
    // Both should be valid PDFs (start with %PDF-1.7)
    const cargoHeader = cargoOutputPdf.toString('utf8', 0, 10)
    const wasmHeader = wasmPdf.toString('utf8', 0, 10)
    expect(cargoHeader).toMatch(/^%PDF-1\.\d/)
    expect(wasmHeader).toMatch(/^%PDF-1\.\d/)
    
    // Both should have same Typst creator
    const cargoCreator = cargoOutputPdf.toString('utf8').includes('Creator (Typst 0.13.1)')
    const wasmCreator = wasmPdf.toString('utf8').includes('Creator (Typst 0.13.1)')
    expect(cargoCreator).toBe(true)
    expect(wasmCreator).toBe(true)
  })
})
